# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц вы найдете в методичке.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения 2х объектов класса Matrix (2х матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно —
# первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.


class Matrix:
    def __init__(self, list_1, list_2):
        self.list_1 = list_1
        self.list_2 = list_2

    def __add__(self):
        mtx = [[0, 0, 0, 0],
               [0, 0, 0, 0],
               [0, 0, 0, 0]]

        for i in range(len(self.list_1)):
            for j in range(len(self.list_2[i])):
                mtx[i][j] = self.list_1[i][j] + self.list_2[i][j]
        return str('\n'.join(['\t'.join([str(j) for j in i]) for i in mtx]))


# реализовано только для матриц одинаковой размерности 4 на 3:
first_matrix = ([[3, 5, 32, 0],
                 [2, 4, 6, 0],
                 [-1, 64, -8, 0]])

second_matrix = ([[3, 5, 8, 3],
                  [8, 3, 7, 1],
                  [0, 0, 0, 0]])

sum_matrix = Matrix(first_matrix, second_matrix)

print(sum_matrix.__add__())

# не придумал, как реализовать логику сложения матриц различной размерности, т.е. чтобы
# автоматически добавлялись нули к той матрице, размерность которой больше.
# приблизительно:
# if len(first_matrix[i]) > len(second_matrix[i]):
#     for i in first_matrix:
#         while len(first_matrix[i]) > len(second_matrix[i]):
#             second_matrix[i].append(0)
# и тогда внутри класса каждому списку в списке mtx тоже надо добавить нужное кол-во нулей